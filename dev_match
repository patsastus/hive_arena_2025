package main

import (
	"strings"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"sync"
	"time"
)

// Configurations
const (
	ServerURL = "localhost:8000"
	HistoryDir = "./arena/history"
	ViewerPath = "./arena/viewer"
	DefaultSrc = "./agent" // Default path to your main agent
)

var MapPool = []string{"balanced", "inverted", "scarce", "tiny"}

// AgentBuild represents a compiled agent binary
type AgentBuild struct {
	Name       string // Friendly name (e.g., "Main", "Experimental")
	SourcePath string // Where the code lives
	BinaryPath string // Where the temp binary lives
	Args       string
}

// MatchConfig holds the setup for this specific run
type MatchConfig struct {
	MapName string
	Count   int
	Roster  []*AgentBuild // Which build runs in slot 1, slot 2, etc.
}

func main() {
	log.SetFlags(0)
	rand.Seed(time.Now().UnixNano())

	// 1. Parse Flags
	mapFlag := flag.String("map", "", "Map name (balanced, inverted, scarce, tiny)")
	countFlag := flag.Int("n", 0, "Number of agents (2-6)")
	vsFlag := flag.String("vs", "", "Path to a challenger agent (e.g. ./experiments/new_path)")
	mainFlag := flag.String("main", DefaultSrc, "Path to main agent source")
	mainArgs := flag.String("main-args", "", "Args for Main (e.g. '-bees 5')")
    vsArgs   := flag.String("vs-args", "", "Args for Challenger (e.g. '-bees 10')")

	flag.Parse()	

	// 2. Determine Configuration
	config := setupConfig(*mapFlag, *countFlag, *mainFlag, *vsFlag, *mainArgs, *vsArgs)
	
	log.Printf("üìã Configuration: Map=[%s], Agents=[%d]", config.MapName, config.Count)

	// 3. Build Agents
	// We map unique source paths to builds so we don't build the same thing twice
	uniqueBuilds := make(map[string]*AgentBuild)
	for _, agent := range config.Roster {
		if _, exists := uniqueBuilds[agent.Name]; !exists {
			uniqueBuilds[agent.Name] = agent
		}
	}

	log.Println("üî® Building agents...")
	for _, build := range uniqueBuilds {
		if err := compileAgent(build); err != nil {
			log.Fatalf("‚ùå Build failed for %s: %v", build.Name, err)
		}
		defer os.Remove(build.BinaryPath) // Schedule cleanup
	}

	// 4. Create Game
	gameID := createGame(config.MapName, config.Count)
	
	// 5. Launch Agents
	var wg sync.WaitGroup
	wg.Add(config.Count)

	log.Println("üöÄ Launching roster...")
	for i, agentBuild := range config.Roster {
		playerNum := i + 1 // Server is 1-indexed
		go func(pNum int, build *AgentBuild) {
			defer wg.Done()
			runAgent(pNum, gameID, build)
		}(playerNum, agentBuild)
	}

	wg.Wait()
	log.Println("üèÅ Match finished.")

	// 6. View Results
	launchViewer()
}

// --- Helper Functions ---

func setupConfig(mapName string, count int, mainPath, vsPath, mainArgs, vsArgs string) MatchConfig {
	cfg := MatchConfig{}

	// Randomize Map if empty
	if mapName == "" {
		cfg.MapName = MapPool[rand.Intn(len(MapPool))]
	} else {
		cfg.MapName = mapName
	}

	// Randomize Count if 0
	if count == 0 {
		cfg.Count = rand.Intn(5) + 2 // Random 2 to 6
	} else {
		cfg.Count = count
	}

	// Define Builds
	mainBuild := &AgentBuild{
		Name:       "Main",
		SourcePath: mainPath,
		BinaryPath: fmt.Sprintf("./bin_main_%d", time.Now().UnixNano()),
		Args:		mainArgs,
	}

	var vsBuild *AgentBuild
	if vsPath != "" {
		vsBuild = &AgentBuild{
			Name:       "Challenger",
			SourcePath: vsPath,
			BinaryPath: fmt.Sprintf("./bin_vs_%d", time.Now().UnixNano()),
			Args:		vsArgs,
		}
	}

	// Populate Roster (Round Robin if VS mode)
	for i := 0; i < cfg.Count; i++ {
		if vsBuild != nil && i%2 != 0 {
			cfg.Roster = append(cfg.Roster, vsBuild)
		} else {
			cfg.Roster = append(cfg.Roster, mainBuild)
		}
	}

	return cfg
}

func compileAgent(build *AgentBuild) error {
	log.Printf("   Compiling %s (%s)...", build.Name, build.SourcePath)
	
	// Ensure absolute path for binary output to avoid confusion
	absBin, _ := filepath.Abs(build.BinaryPath)
	
	cmd := exec.Command("go", "build", "-o", absBin, ".")
	cmd.Dir = build.SourcePath
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func createGame(mapName string, players int) string {
	reqURL := fmt.Sprintf("http://%s/newgame?map=%s&players=%d", ServerURL, mapName, players)
	resp, err := http.Get(reqURL)
	if err != nil {
		log.Fatalf("‚ùå Server connection failed: %v", err)
	}
	defer resp.Body.Close()

	var result struct {
		ID string `json:"id"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		log.Fatalf("‚ùå Failed to parse server response: %v", err)
	}
	log.Printf("‚úÖ Game Created: %s", result.ID)
	return result.ID
}

func runAgent(playerNum int, gameID string, build *AgentBuild) {
	// Make the team name indicate the agent version
	teamName := fmt.Sprintf("%s-P%d", build.Name, playerNum)

	cmdArgs := []string{}
    if build.Args != "" {
        cmdArgs = append(cmdArgs, strings.Fields(build.Args)...) //'...' after a slice apparently unrolls it to all elements. go Go
    }
	cmdArgs = append(cmdArgs, ServerURL, gameID, teamName)	
	cmd := exec.Command(build.BinaryPath, cmdArgs...) // again with the unrolling
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		log.Printf("üíÄ Player %d (%s) exited with error: %v", playerNum, build.Name, err)
	}
}

func launchViewer() {
	log.Println("üîé Scanning for replay...")
	time.Sleep(500 * time.Millisecond) // Wait for file write

	entries, err := os.ReadDir(HistoryDir)
	if err != nil {
		log.Printf("‚ö†Ô∏è  Could not read history directory: %v", err)
		return
	}

	var newestFile string
	var newestTime time.Time

	for _, entry := range entries {
		if entry.IsDir() { continue }
		info, err := entry.Info()
		if err != nil { continue }
		if info.ModTime().After(newestTime) {
			newestTime = info.ModTime()
			newestFile = entry.Name()
		}
	}

	if newestFile == "" {
		log.Println("‚ö†Ô∏è  No history files found.")
		return
	}

	fullHistoryPath := filepath.Join(HistoryDir, newestFile)
	log.Printf("üé¨ Opening Viewer: %s", newestFile)

	cmd := exec.Command("go", "run", ViewerPath, "--file", fullHistoryPath)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		log.Printf("‚ùå Viewer failed: %v", err)
	}
}
